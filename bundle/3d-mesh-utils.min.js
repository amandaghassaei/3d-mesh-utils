!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}let n=[];e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),r[0]=Math.max(r[0],t[3*e]),r[1]=Math.max(r[1],t[3*e+1]),r[2]=Math.max(r[2],t[3*e+2]);return{min:o,max:r}},e.calcEdgesIndicesFromIndexedFaces=function(e){const{facesIndices:n}=e,o=n.length/3,r={},s=[];for(let e=0;e<o;e++)for(let o=0;o<3;o++){const c=n[3*e+o],i=n[3*e+(o+1)%3],a=t(c,i);void 0===r[a]&&(r[a]=!0,s.push(c,i))}return s},e.calcEdgesIndicesFromNestedIndexedFaces=function(e){const{facesIndices:n}=e,o=n.length,r={},s=[];for(let e=0;e<o;e++){const o=n[e],c=o.length;for(let e=0;e<c;e++){const n=o[e],i=o[(e+1)%c],a=t(n,i);void 0===r[a]&&(r[a]=!0,s.push(n,i))}}return s},e.calcEdgesIndicesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const r=6*e+2*n;o[r]=t+n,o[r+1]=t+(n+1)%3}}return o},e.makeEdgeHash=t,e.makeFaceHash=function(e){const t=e.length;n.length=t;for(let o=0;o<t;o++)n[o]=e[o];return n.sort(((e,t)=>e-t)),n.join(",")},e.makeTriangleFaceHash=function(e,t,n){const o=Math.min(e,t,n),r=Math.max(e,t,n);return`${o},${e+t+n-o-r},${r}`},e.mergeVertices=function(e){const{vertices:t,uvs:n,vertexNormals:o,vertexColors:r}=e,s=t.length/9,c=[],i=new Uint32Array(3*s),a={};for(let e=0;e<s;e++)for(let s=0;s<3;s++){const l=3*e+s;let f=`${t[3*l]},${t[3*l+1]},${t[3*l+2]}`;if(n){f+=`|${n[2*l]},${n[2*l+1]}`}if(o){f+=`|${o[3*l]},${o[3*l+1]},${o[3*l+2]}`}if(r){f+=`|${r[3*l]},${r[3*l+1]},${r[3*l+2]}`}const d=3*e;let u=a[f];void 0!==u?i[d+s]=u:(u=c.length,i[d+s]=u,a[f]=u,c.push(l))}const l=c.length,f=new Float32Array(3*l);for(let e=0;e<l;e++){const n=c[e];f[3*e]=t[3*n],f[3*e+1]=t[3*n+1],f[3*e+2]=t[3*n+2]}let d,u,h;if(n){d=new Float32Array(2*l);for(let e=0;e<l;e++){const t=c[e];d[2*e]=n[2*t],d[2*e+1]=n[2*t+1]}}if(o){u=new Float32Array(3*l);for(let e=0;e<l;e++){const t=c[e];u[3*e]=o[3*t],u[3*e+1]=o[3*t+1],u[3*e+2]=o[3*t+2]}}if(r){h=new Float32Array(3*l);for(let e=0;e<l;e++){const t=c[e];h[3*e]=r[3*t],h[3*e+1]=r[3*t+1],h[3*e+2]=r[3*t+2]}}return{verticesMerged:f,uvsMerged:d,vertexNormalsMerged:u,vertexColorsMerged:h,facesIndexed:i}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:r,max:s}=o,c=[s[0]-r[0],s[1]-r[1],s[2]-r[2]],i=[(s[0]+r[0])/2,(s[1]+r[1])/2,(s[2]+r[2])/2],a=Math.max(c[0],c[1],c[2]),l=n.length/3;for(let e=0;e<l;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-i[o])/a}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
