!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}let n=[];e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),c[0]=Math.max(c[0],t[3*e]),c[1]=Math.max(c[1],t[3*e+1]),c[2]=Math.max(c[2],t[3*e+2]);return{min:o,max:c}},e.calcEdgesFromIndexedFaces=function(e){const{faceIndices:n}=e,o=n.length/3,c={},r=[];for(let e=0;e<o;e++)for(let o=0;o<3;o++){const i=n[3*e+o],s=n[3*e+(o+1)%3],a=t(i,s);void 0===c[a]&&(c[a]=!0,r.push(i,s))}return r},e.calcEdgesFromNestedIndexedFaces=function(e){const{faceIndices:n}=e,o=n.length,c={},r=[];for(let e=0;e<o;e++){const o=n[e],i=o.length;for(let e=0;e<i;e++){const n=o[e],s=o[(e+1)%i],a=t(n,s);void 0===c[a]&&(c[a]=!0,r.push(n,s))}}return r},e.calcEdgesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const c=6*e+2*n;o[c]=t+n,o[c+1]=t+(n+1)%3}}return o},e.makeEdgeHash=t,e.makeFaceHash=function(e){const t=e.length;n.length=t;for(let o=0;o<t;o++)n[o]=e[o];return n.sort(((e,t)=>e-t)),n.join(",")},e.makeTriangleFaceHash=function(e,t,n){const o=Math.min(e,t,n),c=Math.max(e,t,n);return`${o},${e+t+n-o-c},${c}`},e.mergeVertices=function(e){const{vertices:t}=e,n=t.length/9,o=[],c=new Uint32Array(3*n),r={};for(let e=0;e<n;e++)for(let n=0;n<3;n++){const i=9*e+3*n,s=3*e,a=t[i],f=t[i+1],l=t[i+2],d=`${a},${f},${l}`;let h=r[d];void 0!==h?c[s+n]=h:(h=o.length/3,c[s+n]=h,r[d]=h,o.push(a,f,l))}return{verticesMerged:o,facesIndexed:c}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:c,max:r}=o,i=[r[0]-c[0],r[1]-c[1],r[2]-c[2]],s=[(r[0]+c[0])/2,(r[1]+c[1])/2,(r[2]+c[2])/2],a=Math.max(i[0],i[1],i[2]),f=n.length/3;for(let e=0;e<f;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-s[o])/a}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
