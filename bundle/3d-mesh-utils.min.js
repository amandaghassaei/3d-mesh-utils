!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),c[0]=Math.max(c[0],t[3*e]),c[1]=Math.max(c[1],t[3*e+1]),c[2]=Math.max(c[2],t[3*e+2]);return{min:o,max:c}},e.calcEdgesFromIndexedFaces=function(e){const{faces:t}=e,n=t.length/3,o={},c=[];for(let e=0;e<n;e++)for(let n=0;n<3;n++){const s=t[3*e+n],i=t[3*e+(n+1)%3],r=`${Math.min(s,i)},${Math.max(s,i)}`;void 0===o[r]&&(o[r]=!0,c.push(s,i))}return c},e.calcEdgesFromNestedIndexedFaces=function(e){const{faces:t}=e,n=t.length,o={},c=[];for(let e=0;e<n;e++){const n=t[e],s=n.length;for(let e=0;e<s;e++){const t=n[e],i=n[(e+1)%s],r=`${Math.min(t,i)},${Math.max(t,i)}`;void 0===o[r]&&(o[r]=!0,c.push(t,i))}}return c},e.calcEdgesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const c=6*e+2*n;o[c]=t+n,o[c+1]=t+(n+1)%3}}return o},e.mergeVertices=function(e){const{vertices:t}=e,n=t.length/9,o=[],c=new Uint32Array(3*n),s={};for(let e=0;e<n;e++)for(let n=0;n<3;n++){const i=9*e+3*n,r=3*e,a=t[i],f=t[i+1],l=t[i+2],d=`${a},${f},${l}`;let h=s[d];void 0!==h?c[r+n]=h:(h=o.length/3,c[r+n]=h,s[d]=h,o.push(a,f,l))}return{verticesMerged:o,facesIndexed:c}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:c,max:s}=o,i=[s[0]-c[0],s[1]-c[1],s[2]-c[2]],r=[(s[0]+c[0])/2,(s[1]+c[1])/2,(s[2]+c[2])/2],a=Math.max(i[0],i[1],i[2]),f=n.length/3;for(let e=0;e<f;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-r[o])/a}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
