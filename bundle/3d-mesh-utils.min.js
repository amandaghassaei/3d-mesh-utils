!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],i=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),i[0]=Math.max(i[0],t[3*e]),i[1]=Math.max(i[1],t[3*e+1]),i[2]=Math.max(i[2],t[3*e+2]);return{min:o,max:i}},e.calcEdgesFromIndexedFaces=function(e){const{faceIndices:t}=e,n=t.length/3,o={},i=[];for(let e=0;e<n;e++)for(let n=0;n<3;n++){const c=t[3*e+n],r=t[3*e+(n+1)%3],s=`${Math.min(c,r)},${Math.max(c,r)}`;void 0===o[s]&&(o[s]=!0,i.push(c,r))}return i},e.calcEdgesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const i=6*e+2*n;o[i]=t+n,o[i+1]=t+(n+1)%3}}return o},e.mergeVertices=function(e){const{vertices:t}=e,n=t.length/9,o=[],i=new Uint32Array(3*n),c={};for(let e=0;e<n;e++)for(let n=0;n<3;n++){const r=9*e+3*n,s=3*e,a=t[r],f=t[r+1],l=t[r+2],d=`${a},${f},${l}`;let u=c[d];void 0!==u?i[s+n]=u:(u=o.length/3,i[s+n]=u,c[d]=u,o.push(a,f,l))}return{verticesMerged:o,facesIndexed:i}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:i,max:c}=o,r=[c[0]-i[0],c[1]-i[1],c[2]-i[2]],s=[(c[0]+i[0])/2,(c[1]+i[1])/2,(c[2]+i[2])/2],a=Math.max(r[0],r[1],r[2]),f=n.length/3;for(let e=0;e<f;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-s[o])/a}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
