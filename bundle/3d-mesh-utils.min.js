!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),c[0]=Math.max(c[0],t[3*e]),c[1]=Math.max(c[1],t[3*e+1]),c[2]=Math.max(c[2],t[3*e+2]);return{min:o,max:c}},e.calcEdgesFromIndexedFaces=function(e){const{faceIndices:t}=e,n=t.length/3,o={},c=[];for(let e=0;e<n;e++)for(let n=0;n<3;n++){const i=t[3*e+n],s=t[3*e+(n+1)%3],r=`${Math.min(i,s)},${Math.max(i,s)}`;void 0===o[r]&&(o[r]=!0,c.push(i,s))}return c},e.calcEdgesFromNestedIndexedFaces=function(e){const{faceIndices:t}=e,n=t.length,o={},c=[];for(let e=0;e<n;e++){const n=t[e],i=n.length;for(let e=0;e<i;e++){const t=n[e],s=n[(e+1)%i],r=`${Math.min(t,s)},${Math.max(t,s)}`;void 0===o[r]&&(o[r]=!0,c.push(t,s))}}return c},e.calcEdgesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const c=6*e+2*n;o[c]=t+n,o[c+1]=t+(n+1)%3}}return o},e.mergeVertices=function(e){const{vertices:t}=e,n=t.length/9,o=[],c=new Uint32Array(3*n),i={};for(let e=0;e<n;e++)for(let n=0;n<3;n++){const s=9*e+3*n,r=3*e,a=t[s],f=t[s+1],l=t[s+2],d=`${a},${f},${l}`;let h=i[d];void 0!==h?c[r+n]=h:(h=o.length/3,c[r+n]=h,i[d]=h,o.push(a,f,l))}return{verticesMerged:o,facesIndexed:c}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:c,max:i}=o,s=[i[0]-c[0],i[1]-c[1],i[2]-c[2]],r=[(i[0]+c[0])/2,(i[1]+c[1])/2,(i[2]+c[2])/2],a=Math.max(s[0],s[1],s[2]),f=n.length/3;for(let e=0;e<f;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-r[o])/a}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
