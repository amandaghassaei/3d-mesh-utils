!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MESH_UTILS={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}e.calcBoundingBox=function(e){const{vertices:t}=e,n=t.length/3,o=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];for(let e=0;e<n;e++)o[0]=Math.min(o[0],t[3*e]),o[1]=Math.min(o[1],t[3*e+1]),o[2]=Math.min(o[2],t[3*e+2]),c[0]=Math.max(c[0],t[3*e]),c[1]=Math.max(c[1],t[3*e+1]),c[2]=Math.max(c[2],t[3*e+2]);return{min:o,max:c}},e.calcEdgesFromIndexedFaces=function(e){const{faceIndices:n}=e,o=n.length/3,c={},i=[];for(let e=0;e<o;e++)for(let o=0;o<3;o++){const r=n[3*e+o],s=n[3*e+(o+1)%3],f=t(r,s);void 0===c[f]&&(c[f]=!0,i.push(r,s))}return i},e.calcEdgesFromNestedIndexedFaces=function(e){const{faceIndices:n}=e,o=n.length,c={},i=[];for(let e=0;e<o;e++){const o=n[e],r=o.length;for(let e=0;e<r;e++){const n=o[e],s=o[(e+1)%r],f=t(n,s);void 0===c[f]&&(c[f]=!0,i.push(n,s))}}return i},e.calcEdgesFromNonIndexedFaces=function(e){const{vertices:t}=e,n=t.length/3/3,o=new Uint32Array(6*n);for(let e=0;e<n;e++){const t=3*e;for(let n=0;n<3;n++){const c=6*e+2*n;o[c]=t+n,o[c+1]=t+(n+1)%3}}return o},e.mergeVertices=function(e){const{vertices:t}=e,n=t.length/9,o=[],c=new Uint32Array(3*n),i={};for(let e=0;e<n;e++)for(let n=0;n<3;n++){const r=9*e+3*n,s=3*e,f=t[r],a=t[r+1],l=t[r+2],d=`${f},${a},${l}`;let u=i[d];void 0!==u?c[s+n]=u:(u=o.length/3,c[s+n]=u,i[d]=u,o.push(f,a,l))}return{verticesMerged:o,facesIndexed:c}},e.scaleVerticesToUnitBoundingBox=function(e,t=e.vertices){const{vertices:n,boundingBox:o}=e,{min:c,max:i}=o,r=[i[0]-c[0],i[1]-c[1],i[2]-c[2]],s=[(i[0]+c[0])/2,(i[1]+c[1])/2,(i[2]+c[2])/2],f=Math.max(r[0],r[1],r[2]),a=n.length/3;for(let e=0;e<a;e++)for(let o=0;o<3;o++)t[3*e+o]=(n[3*e+o]-s[o])/f}}));
//# sourceMappingURL=3d-mesh-utils.min.js.map
