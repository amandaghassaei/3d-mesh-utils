{"version":3,"file":"3d-mesh-utils.min.js","sources":["../src/index-utils.ts","../src/geometry-utils.ts"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1: number, index2: number) {\n\treturn `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1: number, index2: number, index3: number) {\n\tconst min = Math.min(index1, index2, index3);\n\tconst max = Math.max(index1, index2, index3);\n\tconst sum = index1 + index2 + index3;\n\treturn `${min},${sum - min - max},${max}`;\n}\n\nlet tempArray: number[] = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param facesIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(facesIndices: number[]) {\n\tconst length = facesIndices.length;\n\ttempArray.length = length;\n\tfor (let i = 0; i < length; i++) {\n\t\ttempArray[i] = facesIndices[i];\n\t}\n\ttempArray.sort((a, b) => (a - b));\n\treturn tempArray.join(',');\n}","import { makeEdgeHash } from './index-utils';\nimport type { BoundingBox, FloatArray } from './types';\n\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh: {\n\tvertices: FloatArray;\n}): BoundingBox {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\tconst min: [number, number, number] = [Infinity, Infinity, Infinity];\n\tconst max: [number, number, number] = [-Infinity, -Infinity, -Infinity];\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tmin[0] = Math.min(min[0], vertices[3 * i]);\n\t\tmin[1] = Math.min(min[1], vertices[3 * i + 1]);\n\t\tmin[2] = Math.min(min[2], vertices[3 * i + 2]);\n\t\tmax[0] = Math.max(max[0], vertices[3 * i]);\n\t\tmax[1] = Math.max(max[1], vertices[3 * i + 1]);\n\t\tmax[2] = Math.max(max[2], vertices[3 * i + 2]);\n\t}\n\treturn { min, max };\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesIndicesFromNestedIndexedFaces(mesh: {\n\tfacesIndices: number[][];\n}) {\n\tconst { facesIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = facesIndices.length;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tconst face = facesIndices[i];\n\t\tconst numVertices = face.length;\n\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\tconst index1 = face[j];\n\t\t\tconst index2 = face[(j + 1) % numVertices];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesIndicesFromIndexedFaces(mesh: {\n\tfacesIndices: Uint32Array | number[];\n}) {\n\tconst { facesIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = facesIndices.length / 3;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edgeIndices: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst index1 = facesIndices[3 * i + j];\n\t\t\tconst index2 = facesIndices[3 * i + (j + 1) % 3];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedgeIndices.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edgeIndices;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesIndicesFromNonIndexedFaces(mesh: {\n\tvertices: FloatArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\t// Vertices are grouped in sets of three to a face.\n\tconst numFaces = numVertices / 3;\n\tconst edges = new Uint32Array(6 * numFaces);\n\tfor (let i = 0; i < numFaces; i ++) {\n\t\tconst index = 3 * i;\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst edgeIndex = 6 * i + 2 * j;\n\t\t\tedges[edgeIndex] = index + j;\n\t\t\tedges[edgeIndex + 1] = index + (j + 1) % 3;\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh: {\n\tvertices: FloatArray;\n\tboundingBox: BoundingBox;\n}, target: FloatArray = mesh.vertices) {\n\tconst { vertices, boundingBox } = mesh;\n\tconst { min, max } = boundingBox;\n\tconst diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\tconst center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n\tconst scale = Math.max(diff[0], diff[1], diff[2]);\n\tconst numNodes = vertices.length / 3;\n\tfor (let i = 0; i < numNodes; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t// Uniform scale.\n\t\t\ttarget[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n\t\t}\n\t}\n}\n\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh: {\n\tvertices: FloatArray;\n\tuvs?: FloatArray;\n\tvertexNormals?: FloatArray;\n\tvertexColors?: FloatArray; \n}) {\n\tconst { vertices, uvs, vertexNormals, vertexColors } = mesh;\n\tconst numFaces = vertices.length / 9;\n\tconst previousIndexMap: number[] = [];// Map from old vertex index to new vertex index.\n\tconst facesIndexed = new Uint32Array(numFaces * 3);\n\t// Use hash to merge vertices.\n\tconst vertexHash: { [key: string]: number } = {};\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst vertexIndex = 3 * i + j;\n\t\t\tconst positionX = vertices[3 * vertexIndex];\n\t\t\tconst positionY = vertices[3 * vertexIndex + 1];\n\t\t\tconst positionZ = vertices[3 * vertexIndex + 2];\n\t\t\tlet key = `${positionX},${positionY},${positionZ}`;\n\t\t\tif (uvs) {\n\t\t\t\tconst uvX = uvs[2 * vertexIndex];\n\t\t\t\tconst uvY = uvs[2 * vertexIndex + 1];\n\t\t\t\tkey += `|${uvX},${uvY}`;\n\t\t\t}\n\t\t\tif (vertexNormals) {\n\t\t\t\tconst normalX = vertexNormals[3 * vertexIndex];\n\t\t\t\tconst normalY = vertexNormals[3 * vertexIndex + 1];\n\t\t\t\tconst normalZ = vertexNormals[3 * vertexIndex + 2];\n\t\t\t\tkey += `|${normalX},${normalY},${normalZ}`;\n\t\t\t}\n\t\t\tif (vertexColors) {\n\t\t\t\tconst colorR = vertexColors[3 * vertexIndex];\n\t\t\t\tconst colorG = vertexColors[3 * vertexIndex + 1];\n\t\t\t\tconst colorB = vertexColors[3 * vertexIndex + 2];\n\t\t\t\tkey += `|${colorR},${colorG},${colorB}`;\n\t\t\t}\n\t\t\tconst faceIndex = 3 * i;\n\t\t\tlet mergedVertexIndex = vertexHash[key];\n\t\t\tif (mergedVertexIndex !== undefined) {\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t} else {\n\t\t\t\t// Add new vertex.\n\t\t\t\tmergedVertexIndex = previousIndexMap.length;\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t\tvertexHash[key] = mergedVertexIndex;\n\t\t\t\tpreviousIndexMap.push(vertexIndex);\n\t\t\t}\n\t\t}\n\t}\n\tconst numMergedVertices = previousIndexMap.length;\n\tconst verticesMerged = new Float32Array(numMergedVertices * 3);\n\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\tconst previousIndex = previousIndexMap[i];\n\t\tverticesMerged[3 * i] = vertices[3 * previousIndex];\n\t\tverticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n\t\tverticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n\t}\n\tlet uvsMerged: FloatArray | undefined;\n\tif (uvs) {\n\t\tuvsMerged = new Float32Array(numMergedVertices * 2);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tuvsMerged[2 * i] = uvs[2 * previousIndex];\n\t\t\tuvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n\t\t}\n\t}\n\tlet vertexNormalsMerged: FloatArray | undefined;\n\tif (vertexNormals) {\n\t\tvertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tvertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n\t\t\tvertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n\t\t\tvertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n\t\t}\n\t}\n\tlet vertexColorsMerged: FloatArray | undefined;\n\tif (vertexColors) {\n\t\tvertexColorsMerged = new Float32Array(numMergedVertices * 3);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tvertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n\t\t\tvertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n\t\t\tvertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n\t\t}\n\t}\n\treturn {\n\t\tverticesMerged,\n\t\tuvsMerged,\n\t\tvertexNormalsMerged,\n\t\tvertexColorsMerged,\n\t\tfacesIndexed,\n\t};\n}"],"names":["makeEdgeHash","index1","index2","Math","min","max","tempArray","mesh","vertices","numVertices","length","Infinity","i","facesIndices","numFaces","edgesHash","edgeIndices","j","key","undefined","push","edges","face","Uint32Array","index","edgeIndex","sort","a","b","join","index3","uvs","vertexNormals","vertexColors","previousIndexMap","facesIndexed","vertexHash","vertexIndex","faceIndex","mergedVertexIndex","numMergedVertices","verticesMerged","Float32Array","previousIndex","uvsMerged","vertexNormalsMerged","vertexColorsMerged","target","boundingBox","diff","center","scale","numNodes"],"mappings":"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"}