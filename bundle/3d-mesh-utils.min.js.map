{"version":3,"file":"3d-mesh-utils.min.js","sources":["../src/geometry-utils.ts"],"sourcesContent":["import type { BoundingBox, VertexArray } from './types';\n\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh: {\n\tvertices: VertexArray;\n}): BoundingBox {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\tconst min: [number, number, number] = [Infinity, Infinity, Infinity];\n\tconst max: [number, number, number] = [-Infinity, -Infinity, -Infinity];\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tmin[0] = Math.min(min[0], vertices[3 * i]);\n\t\tmin[1] = Math.min(min[1], vertices[3 * i + 1]);\n\t\tmin[2] = Math.min(min[2], vertices[3 * i + 2]);\n\t\tmax[0] = Math.max(max[0], vertices[3 * i]);\n\t\tmax[1] = Math.max(max[1], vertices[3 * i + 1]);\n\t\tmax[2] = Math.max(max[2], vertices[3 * i + 2]);\n\t}\n\treturn { min, max };\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesFromNestedIndexedFaces(mesh: {\n\tfaceIndices: number[][];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tconst face = faceIndices[i];\n\t\tconst numVertices = face.length;\n\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\tconst index1 = face[j];\n\t\t\tconst index2 = face[(j + 1) % numVertices];\n\t\t\tconst key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesFromIndexedFaces(mesh: {\n\tfaceIndices: Uint32Array | number[];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length / 3;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst index1 = faceIndices[3 * i + j];\n\t\t\tconst index2 = faceIndices[3 * i + (j + 1) % 3];\n\t\t\tconst key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesFromNonIndexedFaces(mesh: {\n\tvertices: VertexArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\t// Vertices are grouped in sets of three to a face.\n\tconst numFaces = numVertices / 3;\n\tconst edges = new Uint32Array(6 * numFaces);\n\tfor (let i = 0; i < numFaces; i ++) {\n\t\tconst index = 3 * i;\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst edgeIndex = 6 * i + 2 * j;\n\t\t\tedges[edgeIndex] = index + j;\n\t\t\tedges[edgeIndex + 1] = index + (j + 1) % 3;\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh: {\n\tvertices: VertexArray;\n\tboundingBox: BoundingBox;\n}, target: VertexArray = mesh.vertices) {\n\tconst { vertices, boundingBox } = mesh;\n\tconst { min, max } = boundingBox;\n\tconst diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\tconst center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n\tconst scale = Math.max(diff[0], diff[1], diff[2]);\n\tconst numNodes = vertices.length / 3;\n\tfor (let i = 0; i < numNodes; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t// Uniform scale.\n\t\t\ttarget[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n\t\t}\n\t}\n}\n\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh: {\n\tvertices: VertexArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numFaces = vertices.length / 9;\n\tconst verticesMerged: number[] = [];\n\tconst facesIndexed = new Uint32Array(numFaces * 3);\n\t// Use hash to merge vertices.\n\tconst vertexHash: { [key: string]: number } = {};\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst vertexIndex = 9 * i + 3 * j;\n\t\t\tconst faceIndex = 3 * i;\n\t\t\tconst positionX = vertices[vertexIndex];\n\t\t\tconst positionY = vertices[vertexIndex + 1];\n\t\t\tconst positionZ = vertices[vertexIndex + 2];\n\t\t\tconst key = `${positionX},${positionY},${positionZ}`;\n\t\t\tlet mergedVertexIndex = vertexHash[key];\n\t\t\tif (mergedVertexIndex !== undefined) {\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t} else {\n\t\t\t\t// Add new vertex.\n\t\t\t\tmergedVertexIndex = verticesMerged.length / 3;\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t\tvertexHash[key] = mergedVertexIndex;\n\t\t\t\tverticesMerged.push(positionX, positionY, positionZ);\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tverticesMerged,\n\t\tfacesIndexed,\n\t};\n}"],"names":["mesh","vertices","numVertices","length","min","Infinity","max","i","Math","faceIndices","numFaces","edgesHash","edges","j","index1","index2","key","undefined","push","face","Uint32Array","index","edgeIndex","verticesMerged","facesIndexed","vertexHash","vertexIndex","faceIndex","positionX","positionY","positionZ","mergedVertexIndex","target","boundingBox","diff","center","scale","numNodes"],"mappings":"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"}