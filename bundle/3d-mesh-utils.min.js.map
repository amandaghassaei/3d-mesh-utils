{"version":3,"file":"3d-mesh-utils.min.js","sources":["../src/index-utils.ts","../src/geometry-utils.ts"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1: number, index2: number) {\n\treturn `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1: number, index2: number, index3: number) {\n\tconst min = Math.min(index1, index2, index3);\n\tconst max = Math.max(index1, index2, index3);\n\tconst sum = index1 + index2 + index3;\n\treturn `${min},${sum - min - max},${max}`;\n}\n\nlet tempArray: number[] = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param faceIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(faceIndices: number[]) {\n\tconst length = faceIndices.length;\n\ttempArray.length = length;\n\tfor (let i = 0; i < length; i++) {\n\t\ttempArray[i] = faceIndices[i];\n\t}\n\ttempArray.sort((a, b) => (a - b));\n\treturn tempArray.join(',');\n}","import { makeEdgeHash } from './index-utils';\nimport type { BoundingBox, VertexArray } from './types';\n\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh: {\n\tvertices: VertexArray;\n}): BoundingBox {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\tconst min: [number, number, number] = [Infinity, Infinity, Infinity];\n\tconst max: [number, number, number] = [-Infinity, -Infinity, -Infinity];\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tmin[0] = Math.min(min[0], vertices[3 * i]);\n\t\tmin[1] = Math.min(min[1], vertices[3 * i + 1]);\n\t\tmin[2] = Math.min(min[2], vertices[3 * i + 2]);\n\t\tmax[0] = Math.max(max[0], vertices[3 * i]);\n\t\tmax[1] = Math.max(max[1], vertices[3 * i + 1]);\n\t\tmax[2] = Math.max(max[2], vertices[3 * i + 2]);\n\t}\n\treturn { min, max };\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesFromNestedIndexedFaces(mesh: {\n\tfaceIndices: number[][];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tconst face = faceIndices[i];\n\t\tconst numVertices = face.length;\n\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\tconst index1 = face[j];\n\t\t\tconst index2 = face[(j + 1) % numVertices];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesFromIndexedFaces(mesh: {\n\tfaceIndices: Uint32Array | number[];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length / 3;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst index1 = faceIndices[3 * i + j];\n\t\t\tconst index2 = faceIndices[3 * i + (j + 1) % 3];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesFromNonIndexedFaces(mesh: {\n\tvertices: VertexArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\t// Vertices are grouped in sets of three to a face.\n\tconst numFaces = numVertices / 3;\n\tconst edges = new Uint32Array(6 * numFaces);\n\tfor (let i = 0; i < numFaces; i ++) {\n\t\tconst index = 3 * i;\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst edgeIndex = 6 * i + 2 * j;\n\t\t\tedges[edgeIndex] = index + j;\n\t\t\tedges[edgeIndex + 1] = index + (j + 1) % 3;\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh: {\n\tvertices: VertexArray;\n\tboundingBox: BoundingBox;\n}, target: VertexArray = mesh.vertices) {\n\tconst { vertices, boundingBox } = mesh;\n\tconst { min, max } = boundingBox;\n\tconst diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\tconst center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n\tconst scale = Math.max(diff[0], diff[1], diff[2]);\n\tconst numNodes = vertices.length / 3;\n\tfor (let i = 0; i < numNodes; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t// Uniform scale.\n\t\t\ttarget[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n\t\t}\n\t}\n}\n\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh: {\n\tvertices: VertexArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numFaces = vertices.length / 9;\n\tconst verticesMerged: number[] = [];\n\tconst facesIndexed = new Uint32Array(numFaces * 3);\n\t// Use hash to merge vertices.\n\tconst vertexHash: { [key: string]: number } = {};\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst vertexIndex = 9 * i + 3 * j;\n\t\t\tconst faceIndex = 3 * i;\n\t\t\tconst positionX = vertices[vertexIndex];\n\t\t\tconst positionY = vertices[vertexIndex + 1];\n\t\t\tconst positionZ = vertices[vertexIndex + 2];\n\t\t\tconst key = `${positionX},${positionY},${positionZ}`;\n\t\t\tlet mergedVertexIndex = vertexHash[key];\n\t\t\tif (mergedVertexIndex !== undefined) {\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t} else {\n\t\t\t\t// Add new vertex.\n\t\t\t\tmergedVertexIndex = verticesMerged.length / 3;\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t\tvertexHash[key] = mergedVertexIndex;\n\t\t\t\tverticesMerged.push(positionX, positionY, positionZ);\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tverticesMerged,\n\t\tfacesIndexed,\n\t};\n}"],"names":["makeEdgeHash","index1","index2","Math","min","max","mesh","vertices","numVertices","length","Infinity","i","faceIndices","numFaces","edgesHash","edges","j","key","undefined","push","face","Uint32Array","index","edgeIndex","verticesMerged","facesIndexed","vertexHash","vertexIndex","faceIndex","positionX","positionY","positionZ","mergedVertexIndex","target","boundingBox","diff","center","scale","numNodes"],"mappings":"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"}