{"version":3,"file":"3d-mesh-utils.min.js","sources":["../src/index-utils.ts","../src/geometry-utils.ts"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1: number, index2: number) {\n\treturn `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1: number, index2: number, index3: number) {\n\tconst min = Math.min(index1, index2, index3);\n\tconst max = Math.max(index1, index2, index3);\n\tconst sum = index1 + index2 + index3;\n\treturn `${min},${sum - min - max},${max}`;\n}\n\nlet tempArray: number[] = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param faceIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(faceIndices: number[]) {\n\tconst length = faceIndices.length;\n\ttempArray.length = length;\n\tfor (let i = 0; i < length; i++) {\n\t\ttempArray[i] = faceIndices[i];\n\t}\n\ttempArray.sort((a, b) => (a - b));\n\treturn tempArray.join(',');\n}","import { makeEdgeHash } from './index-utils';\nimport type { BoundingBox, FloatArray } from './types';\n\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh: {\n\tvertices: FloatArray;\n}): BoundingBox {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\tconst min: [number, number, number] = [Infinity, Infinity, Infinity];\n\tconst max: [number, number, number] = [-Infinity, -Infinity, -Infinity];\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tmin[0] = Math.min(min[0], vertices[3 * i]);\n\t\tmin[1] = Math.min(min[1], vertices[3 * i + 1]);\n\t\tmin[2] = Math.min(min[2], vertices[3 * i + 2]);\n\t\tmax[0] = Math.max(max[0], vertices[3 * i]);\n\t\tmax[1] = Math.max(max[1], vertices[3 * i + 1]);\n\t\tmax[2] = Math.max(max[2], vertices[3 * i + 2]);\n\t}\n\treturn { min, max };\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgeIndicesFromNestedIndexedFaces(mesh: {\n\tfaceIndices: number[][];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tconst face = faceIndices[i];\n\t\tconst numVertices = face.length;\n\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\tconst index1 = face[j];\n\t\t\tconst index2 = face[(j + 1) % numVertices];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesFromIndexedFaces(mesh: {\n\tfaceIndices: Uint32Array | number[];\n}) {\n\tconst { faceIndices } = mesh;\n\t// Handle edges on indexed faces.\n\tconst numFaces = faceIndices.length / 3;\n\t// Use hash to calc edges.\n\tconst edgesHash : { [key: string]: boolean } = {};\n\tconst edges: number[] = [];\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst index1 = faceIndices[3 * i + j];\n\t\t\tconst index2 = faceIndices[3 * i + (j + 1) % 3];\n\t\t\tconst key = makeEdgeHash(index1, index2);\n\t\t\t// Only add each edge once.\n\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\tedgesHash[key] = true;\n\t\t\t\tedges.push(index1, index2);\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgeIndicesFromNonIndexedFaces(mesh: {\n\tvertices: FloatArray;\n}) {\n\tconst { vertices } = mesh;\n\tconst numVertices = vertices.length / 3;\n\t// Vertices are grouped in sets of three to a face.\n\tconst numFaces = numVertices / 3;\n\tconst edges = new Uint32Array(6 * numFaces);\n\tfor (let i = 0; i < numFaces; i ++) {\n\t\tconst index = 3 * i;\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst edgeIndex = 6 * i + 2 * j;\n\t\t\tedges[edgeIndex] = index + j;\n\t\t\tedges[edgeIndex + 1] = index + (j + 1) % 3;\n\t\t}\n\t}\n\treturn edges;\n}\n\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh: {\n\tvertices: FloatArray;\n\tboundingBox: BoundingBox;\n}, target: FloatArray = mesh.vertices) {\n\tconst { vertices, boundingBox } = mesh;\n\tconst { min, max } = boundingBox;\n\tconst diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\tconst center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n\tconst scale = Math.max(diff[0], diff[1], diff[2]);\n\tconst numNodes = vertices.length / 3;\n\tfor (let i = 0; i < numNodes; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t// Uniform scale.\n\t\t\ttarget[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n\t\t}\n\t}\n}\n\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh: {\n\tvertices: FloatArray;\n\tuvs?: FloatArray;\n\tvertexNormals?: FloatArray;\n\tvertexColors?: FloatArray; \n}) {\n\tconst { vertices, uvs, vertexNormals, vertexColors } = mesh;\n\tconst numFaces = vertices.length / 9;\n\tconst previousIndexMap: number[] = [];// Map from old vertex index to new vertex index.\n\tconst facesIndexed = new Uint32Array(numFaces * 3);\n\t// Use hash to merge vertices.\n\tconst vertexHash: { [key: string]: number } = {};\n\tfor (let i = 0; i < numFaces; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tconst vertexIndex = 3 * i + j;\n\t\t\tconst positionX = vertices[3 * vertexIndex];\n\t\t\tconst positionY = vertices[3 * vertexIndex + 1];\n\t\t\tconst positionZ = vertices[3 * vertexIndex + 2];\n\t\t\tlet key = `${positionX},${positionY},${positionZ}`;\n\t\t\tif (uvs) {\n\t\t\t\tconst uvX = uvs[2 * vertexIndex];\n\t\t\t\tconst uvY = uvs[2 * vertexIndex + 1];\n\t\t\t\tkey += `|${uvX},${uvY}`;\n\t\t\t}\n\t\t\tif (vertexNormals) {\n\t\t\t\tconst normalX = vertexNormals[3 * vertexIndex];\n\t\t\t\tconst normalY = vertexNormals[3 * vertexIndex + 1];\n\t\t\t\tconst normalZ = vertexNormals[3 * vertexIndex + 2];\n\t\t\t\tkey += `|${normalX},${normalY},${normalZ}`;\n\t\t\t}\n\t\t\tif (vertexColors) {\n\t\t\t\tconst colorR = vertexColors[3 * vertexIndex];\n\t\t\t\tconst colorG = vertexColors[3 * vertexIndex + 1];\n\t\t\t\tconst colorB = vertexColors[3 * vertexIndex + 2];\n\t\t\t\tkey += `|${colorR},${colorG},${colorB}`;\n\t\t\t}\n\t\t\tconst faceIndex = 3 * i;\n\t\t\tlet mergedVertexIndex = vertexHash[key];\n\t\t\tif (mergedVertexIndex !== undefined) {\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t} else {\n\t\t\t\t// Add new vertex.\n\t\t\t\tmergedVertexIndex = previousIndexMap.length;\n\t\t\t\tfacesIndexed[faceIndex + j] = mergedVertexIndex;\n\t\t\t\tvertexHash[key] = mergedVertexIndex;\n\t\t\t\tpreviousIndexMap.push(vertexIndex);\n\t\t\t}\n\t\t}\n\t}\n\tconst numMergedVertices = previousIndexMap.length;\n\tconst verticesMerged = new Float32Array(numMergedVertices * 3);\n\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\tconst previousIndex = previousIndexMap[i];\n\t\tverticesMerged[3 * i] = vertices[3 * previousIndex];\n\t\tverticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n\t\tverticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n\t}\n\tlet uvsMerged: FloatArray | undefined;\n\tif (uvs) {\n\t\tuvsMerged = new Float32Array(numMergedVertices * 2);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tuvsMerged[2 * i] = uvs[2 * previousIndex];\n\t\t\tuvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n\t\t}\n\t}\n\tlet vertexNormalsMerged: FloatArray | undefined;\n\tif (vertexNormals) {\n\t\tvertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tvertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n\t\t\tvertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n\t\t\tvertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n\t\t}\n\t}\n\tlet vertexColorsMerged: FloatArray | undefined;\n\tif (vertexColors) {\n\t\tvertexColorsMerged = new Float32Array(numMergedVertices * 3);\n\t\tfor (let i = 0; i < numMergedVertices; i++) {\n\t\t\tconst previousIndex = previousIndexMap[i];\n\t\t\tvertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n\t\t\tvertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n\t\t\tvertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n\t\t}\n\t}\n\treturn {\n\t\tverticesMerged,\n\t\tuvsMerged,\n\t\tvertexNormalsMerged,\n\t\tvertexColorsMerged,\n\t\tfacesIndexed,\n\t};\n}"],"names":["makeEdgeHash","index1","index2","Math","min","max","tempArray","mesh","vertices","numVertices","length","Infinity","i","faceIndices","numFaces","edgesHash","edges","face","j","key","undefined","push","Uint32Array","index","edgeIndex","sort","a","b","join","index3","uvs","vertexNormals","vertexColors","previousIndexMap","facesIndexed","vertexHash","vertexIndex","faceIndex","mergedVertexIndex","numMergedVertices","verticesMerged","Float32Array","previousIndex","uvsMerged","vertexNormalsMerged","vertexColorsMerged","target","boundingBox","diff","center","scale","numNodes"],"mappings":"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"}